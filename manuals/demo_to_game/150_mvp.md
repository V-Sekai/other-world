# MVP Proposal

The goal of this project is to develop a VR environment using Godot and Elixir. The MVP will concentrate on creating an interactive virtual space with basic physics, capable of supporting up to 1000 player entities.

## Key Features

1. **VR Prototype**: A simple VR environment with interactive objects and basic physics.
2. **Networking**: Development of a client-server network model for real-time communication between players.
3. **Scalability**: Ensuring the system can support up to 1000 player entities.

## Development Approach

We'll begin by creating classes for each type of object (e.g., chair, avatar, ball) that inherit from a base GameObject class. Each class will have properties like name, user_uid, attachments, scale, skeleton, and an array of interactions. We'll implement methods within these classes to allow for manipulation such as dragging and scaling, and also to add or remove interactions based on the object's state.

Our network model will be a client-server model. This model allows all players in the game to interact with the objects and send their states to the server. The server then updates the state of the game and sends it back to the clients. This model is more secure than a distributed simulation model and requires less computational power from the client side.

## Testing and Feedback

We'll define various testing scenarios under different conditions, particularly focusing on concurrent interactions and network latency. We'll also gather data on system performance and user experience, and iteratively refine the system based on feedback.

By applying a smart object interaction model and using a client-server network model, we aim to create a dynamic and interactive environment where players can manipulate objects and share their states with other players. The chair, as a standard test item, will be an excellent starting point for implementing this pattern.

## References

[Networked Physics in Virtual Reality](https://gafferongames.com/post/networked_physics_in_virtual_reality/)

# Scenario: Avatar Interacts with a Chair

#### Initial Setup

Let's assume that each avatar and chair has a state stored in the server. The state includes various attributes like position, ownership, and whether the chair is currently occupied or not.

#### Incremental State Changes

When an avatar interacts with a chair, such as sitting down on it, only the relevant changes to the state are recorded. For example:

- The chair's state change: The `occupied` attribute changes from `false` to `true`, and the `occupied_by` attribute is updated to the ID of the avatar.
- The avatar's state change: The `sitting` attribute changes from `false` to `true`, and the `sitting_on` attribute is updated to the ID of the chair.

These changes are then sent to the server to update the respective states.

```elixir
server.put(chair_path, %{occupied: true, occupied_by: avatar_id})
server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

This method only modifies the parts of the state that have changed, making it very efficient.

#### Synchronization

After the state has been updated in the server, it's important to synchronize this new state across all clients to maintain consistency in the game. This could involve broadcasting the updated state to all clients, or sending specific updates to the clients that are affected by the change.

### Advantages of This Approach

1. **Efficiency**: By only sending the changes instead of the full state, we can reduce the usage of network bandwidth, which is very important for a real-time multiplayer game.
2. **Speed**: Applying small changes is generally faster than processing the entire state, which leads to quicker updates.
3. **Scalability**: This approach scales well with an increasing number of players and interactions, as each change is handled independently.
4. **Consistency**: Using a client-server model ensures that the state remains consistent across the server and all clients, even when there are concurrent interactions happening.

## Avoiding the O(n^n) State Update Problem

The O(n^n) state update problem arises when every change in state requires updating all other states, leading to an exponential increase in computations as the number of states (n) increases. This can be a significant issue in a VR environment with many interactive objects and players.

To avoid this problem, we can use the following strategies:

### 1. Incremental State Updates

As mentioned earlier, when an avatar interacts with an object like a chair, only the relevant changes to the state are recorded and sent to the server. This means that instead of updating the entire state for every interaction, we only modify the parts of the state that have changed.

```elixir
server.put(chair_path, %{occupied: true, occupied_by: avatar_id})
server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

This approach significantly reduces the amount of data that needs to be processed and transmitted, making it much more efficient.

### 2. Event-Driven Updates

Instead of continuously updating all states, we can use an event-driven model where updates are triggered by specific events. For example, when an avatar sits on a chair, an event is triggered which updates the states of the avatar and the chair. This way, we only perform updates when necessary, reducing the computational load.

### 3. Spatial Partitioning

In a large VR environment, not all objects interact with each other. We can divide the environment into smaller regions or partitions, and only update the states within the same partition. This technique, known as spatial partitioning, can greatly reduce the number of state updates required.

### 4. Prioritizing Updates

Not all state updates are equally important. Some updates might have a bigger impact on the game than others. By prioritizing updates based on their importance, we can ensure that the most critical updates are processed first, improving the overall performance and responsiveness of the game.

By using these strategies, we can avoid the O(n^n) state update problem and ensure that our VR environment remains scalable and efficient, even as the number of players and interactions increases.
