# MVP with Rigid Body Physics

## Key Features

1. **Event-Driven**: The system reacts to events (e.g., avatar sits on chair) rather than being updated every tick.
2. **Physics**: The chair behaves as a rigid body, reacting to forces applied by the avatar. It has properties such as position, rotation, velocity, and angular velocity.
3. **VR Prototype**: A simple VR environment with one avatar and one chair.
4. **Object Interaction**: The avatar can interact with the chair (e.g., sit on it, push it).
5. **State Changes**: The states of the avatar and the chair change based on their interaction.
6. **Mastership vs Ownership**: The master simulates the physics of the objects, while the owner controls the objects' actions.
7. **Networking**: The state changes are sent to the server, then synchronized across all clients.

## Development Steps

1. **Create the VR Environment**: Use Godot to create a simple VR environment with one avatar and one chair.
2. **Implement Physics**: Make the chair a rigid body that can react to forces. For example, if the avatar pushes the chair, it should move accordingly. The chair's state includes its position, rotation, velocity, and angular velocity.
3. **Implement Object Interaction**: Allow the avatar to interact with the chair. This could include sitting on the chair or applying a force to it.
4. **Handle State Changes**: When the avatar interacts with the chair, update the states of both the avatar and the chair. This includes the position, rotation, velocity, and angular velocity of the chair if it has been moved.

```elixir
# Elixir Khepri
server.put(chair_path, %{position: new_position, rotation: new_rotation, velocity: new_velocity, angular_velocity: new_angular_velocity})
server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

5. **Implement Event-Driven Logic**: Instead of updating the game state every tick, use signals in Godot to trigger updates when certain events occur. For example, when the avatar sits on the chair, emit a signal that triggers the state update.

```gdscript
# Godot GDScript
signal avatar_sits_on_chair

func _on_avatar_sits_on_chair():
    server.put(chair_path, %{position: new_position, rotation: new_rotation, velocity: new_velocity, angular_velocity: new_angular_velocity})
    server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

6. **Encode State Changes**: Before sending the state changes over the network, encode them. This will ensure efficient parsing and hash consistent representations.

```elixir
# Elixir Khepri
encoded_state = encode(%{position: new_position, rotation: new_rotation, velocity: new_velocity, angular_velocity: new_angular_velocity, sitting: true, sitting_on: chair_id})
server.put(encoded_state)
```

7. **Set Up Networking**: Set up a client-server network model using Elixir. When the state changes occur, send them to the server. The server then updates the game state and sends it back to the client(s).
8. **Implement Mastership and Ownership**: Assign mastership and ownership roles for each object in the VR environment. The master will be responsible for simulating the physics of the objects, while the owner will control the objects' actions.
9. **Test the System**: Test the system by interacting with the chair in the VR environment. Check if the state changes, including those related to physics, are correctly sent to the server and synchronized across all clients.

This proof of concept will allow us to validate our approach and identify any potential issues early in the development process. Once this basic functionality is working, we can incrementally add more features, such as additional interactive objects and avatars, more complex physics interactions, and so on.
