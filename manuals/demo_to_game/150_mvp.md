# Event-Driven Approach

While Godot Engine is tick-based, it's possible to implement an event-driven approach within this framework. This can be achieved by using signals in Godot, which are essentially a type of event system.

## Key Features

1. **Event-Driven**: The system reacts to events (e.g., avatar sits on chair) rather than being updated every tick.
2. **Physics**: The chair behaves as a physics object, reacting to forces applied by the avatar.
3. **VR Prototype**: A simple VR environment with one avatar and one chair.
4. **Object Interaction**: The avatar can interact with the chair (e.g., sit on it, push it).
5. **State Changes**: The states of the avatar and the chair change based on their interaction.
6. **Networking**: The state changes are sent to the server and synchronized across all clients.

## Development Steps

1. **Create the VR Environment**: Use Godot to create a simple VR environment with one avatar and one chair.
2. **Implement Physics**: Make the chair a physics object that can react to forces. For example, if the avatar pushes the chair, it should move accordingly.
3. **Implement Object Interaction**: Allow the avatar to interact with the chair. This could include sitting on the chair or applying a force to it.
4. **Handle State Changes**: When the avatar interacts with the chair, update the states of both the avatar and the chair. This includes the position and velocity of the chair if it has been moved.

```elixir
# Elixir Khepri
server.put(chair_path, %{position: new_position, velocity: new_velocity})
server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

5. **Implement Event-Driven Logic**: Instead of updating the game state every tick, use signals in Godot to trigger updates when certain events occur. For example, when the avatar sits on the chair, emit a signal that triggers the state update.

```gdscript
# Godot GDScript
signal avatar_sits_on_chair

func _on_avatar_sits_on_chair():
    server.put(chair_path, %{position: new_position, velocity: new_velocity})
    server.put(avatar_path, %{sitting: true, sitting_on: chair_id})
```

6. **Set Up Networking**: Set up a client-server network model using Elixir. When the state changes occur, send them to the server. The server then updates the game state and sends it back to the client(s).
7. **Test the System**: Test the system by interacting with the chair in the VR environment. Check if the state changes, including those related to physics, are correctly sent to the server and synchronized across all clients.

This proof of concept will allow us to validate our approach and identify any potential issues early in the development process. Once this basic functionality is working, we can incrementally add more features, such as additional interactive objects and avatars, more complex physics interactions, and so on.
